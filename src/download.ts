import * as EC from 'eight-colors';
import Util from './util'; // Assuming util.ts exports Util as default
import * as PB from '@puppeteer/browsers'; // For PB.BrowserPlatform and PB.InstalledBrowser

// Interface for the main options object
interface DownloadOptions {
  revision: string;
  snapshotsDir: string; // Used as cacheDir for Util.install & Util.computeExecutablePath
  platform: PB.BrowserPlatform;
  hosts: string[];
  retry: number; // Max retries

  // Optional or dynamically added properties
  downloadHost?: string; // A single primary download host
  downloadProgressCallback?: (
    downloadedBytes: number,
    totalBytes: number
  ) => void;
  retryNum?: number;
  installedBrowser?: PB.InstalledBrowser;
  executablePath?: string;
}

// Type for the items in the list generated by preDownloadStart
interface HostCheckResult {
  host: string;
  time: number;
  ok: boolean;
  downloadUrl: string;
}

function getFolderNameForPlatform(platform: PB.BrowserPlatform): string {
  switch (platform) {
    case PB.BrowserPlatform.LINUX:
      return 'Linux_x64';
    case PB.BrowserPlatform.LINUX_ARM: // Added case
      return 'Linux_ARM';
    case PB.BrowserPlatform.MAC_ARM:
      return 'Mac_Arm';
    case PB.BrowserPlatform.MAC:
      return 'Mac';
    case PB.BrowserPlatform.WIN32:
      return 'Win';
    case PB.BrowserPlatform.WIN64:
      return 'Win_x64';
    default:
      // This should now be truly exhaustive if all PB.BrowserPlatform members are covered.
      // If @puppeteer/browsers adds new platforms, this will error, which is good.
      const exhaustiveCheck: never = platform;
      Util.output(`Unknown platform for folder: ${exhaustiveCheck}`, true);
      return '';
  }
}

function getArchiveNameForPlatform(
  platform: PB.BrowserPlatform,
  buildId: string
): string {
  switch (platform) {
    case PB.BrowserPlatform.LINUX:
      return 'chrome-linux';
    case PB.BrowserPlatform.LINUX_ARM: // Added case
      return 'chrome-linux-arm'; // Assuming this is the archive name
    case PB.BrowserPlatform.MAC_ARM:
    case PB.BrowserPlatform.MAC:
      return 'chrome-mac';
    case PB.BrowserPlatform.WIN32:
    case PB.BrowserPlatform.WIN64:
      return parseInt(buildId, 10) > 591479 ? 'chrome-win' : 'chrome-win32';
    default:
      const exhaustiveCheck: never = platform;
      Util.output(`Unknown platform for archive: ${exhaustiveCheck}`, true);
      return '';
  }
}

const resolveDownloadPathParts = (
  platform: PB.BrowserPlatform,
  buildId: string
): string[] => {
  return [
    getFolderNameForPlatform(platform),
    buildId,
    `${getArchiveNameForPlatform(platform, buildId)}.zip`,
  ];
};

const resolveDownloadUrl = (
  platform: PB.BrowserPlatform,
  buildId: string,
  baseUrl: string
): string => {
  return `${baseUrl}/${resolveDownloadPathParts(platform, buildId).join('/')}`;
};

const getBaseUrlForHost = (host: string): string => {
  const trimmedHost = host.endsWith('/') ? host.slice(0, -1) : host;
  return `${trimmedHost}/chromium-browser-snapshots`;
};

const downloadFromHost = async (
  options: DownloadOptions,
  host: string
): Promise<PB.InstalledBrowser | undefined> => {
  Util.output(`Downloading from: ${host} ...`);
  Util.createGauge();

  let failed = false;
  const installedBrowser = await Util.install({
    baseUrl: getBaseUrlForHost(host),
    buildId: options.revision,
    cacheDir: options.snapshotsDir,
    platform: options.platform,
    downloadProgressCallback: (downloadedBytes: number, totalBytes: number) => {
      Util.showProgress(downloadedBytes, totalBytes);
    },
  }).catch((error: Error) => {
    failed = true;
    Util.output(error.message || String(error), true);
  });

  await Util.delay(500);
  Util.closeGauge();

  if (failed || !installedBrowser) {
    return undefined;
  }

  Util.output(`Chromium downloaded: ${installedBrowser.buildId}`);
  return installedBrowser;
};

const downloadStart = async (
  options: DownloadOptions,
  list: HostCheckResult[]
): Promise<PB.InstalledBrowser | undefined> => {
  for (const item of list) {
    if (!item.ok) continue;
    const installedBrowser = await downloadFromHost(options, item.host);
    if (installedBrowser) {
      return installedBrowser;
    }
  }

  if ((options.retryNum || 0) < options.retry) {
    options.retryNum = (options.retryNum || 0) + 1;
    Util.output(
      `Retry Chromium downloading ... (Attempt ${options.retryNum}/${options.retry})`
    );
    return downloadStart(options, list);
  }
  return undefined;
};

const preDownloadFromHost = async (
  options: DownloadOptions,
  host: string
): Promise<HostCheckResult> => {
  const time_start = Date.now();
  const { platform, revision } = options;
  const baseUrl = getBaseUrlForHost(host);
  const downloadUrl = resolveDownloadUrl(platform, revision, baseUrl);

  const ok = await Util.headRequest(downloadUrl);
  const time = Date.now() - time_start;

  const available = ok ? EC.green(String(ok)) : EC.red(String(ok));
  Util.output(`Head request: ${downloadUrl} - ${available} (${time}ms)`);

  return {
    host,
    time,
    ok,
    downloadUrl,
  };
};

const preDownloadStart = async (
  options: DownloadOptions
): Promise<HostCheckResult[]> => {
  const list = await Promise.all(
    options.hosts.map((host) => preDownloadFromHost(options, host))
  );

  list.sort((a, b) => {
    if (a.ok && !b.ok) return -1;
    if (!a.ok && b.ok) return 1;
    return a.time - b.time;
  });

  return list;
};

const downloadChromium = async (options: DownloadOptions): Promise<void> => {
  const list = await preDownloadStart(options);

  options.retryNum = 0;
  const installedBrowser = await downloadStart(options, list);

  if (installedBrowser) {
    options.installedBrowser = installedBrowser;
    options.executablePath = Util.computeExecutablePath({
      platform: installedBrowser.platform,
      buildId: installedBrowser.buildId,
      cacheDir: options.snapshotsDir,
    });
  } else {
    Util.output(
      `ERROR: Failed to download Chromium after retry ${
        options.retryNum || 0
      } times.`,
      true
    );
  }
};

export default downloadChromium;
